(setq charC  nil)
(setq readC nil)
(setq currentToken 	nil)
(defun read-as-list (filename)
	;;(print "read-as-list RESULTS :")
	(setq str nil)
	(setq List nil)
	; Reads a file containing one word per line and returns a list of words (each word is in turn a list of characters)."
	(let ((in (open filename :if-does-not-exist nil)))
  (when in
    (loop for line = (read-line in nil)
        while line 
        ;do (format t "ceren ~a~%" line) 
		do (if (equalp line "") ()(setq List (nconc List (list line))))
		)
    (close in)))
	;;(print List)
	(gppinterpreter List)
	;(setq str (subseq str 3))
	;(print str)
	;(split-by-one-space str)

)

(defconstant EndOfFile  0)
(defconstant letter  1)
(defconstant digit   2)
(defconstant undefined 3)


(defun gppinterpreter(list)
	(setq temp nil)
	(setq counter 0)
	(setq tempStr nil)
	(setq result 0)
	(setq wordList nil)
	(setq letList nil)
	(map 'list (lambda (it)
	(setq counter1 0)
	(setq result 0)
	 (loop for iteration = 0 then (1+ jiteration)
          as jiteration = (position #\; it :start iteration) 
          while jiteration do (setq counter1 (+ 1 counter1 )))
	(if (equalp counter1 1) (print "SYNTAX_ERROR Expression not recognized ")(setq counter2 100) )
	(if (equalp (subseq (string it) 0 2) ";;")(print "Syntax OK"))
	(if (equalp (subseq (string it) 0 2) ";;")(setq temp 0))
	(if (equalp (subseq (string it) 0 6) "(defun")(setq temp 2))
	(if (equalp (subseq (string it) 0 5) "(load")(setq temp 1))
	(if (equalp temp 1)(print "Syntax OK"))
	(if (equalp temp 1)(princ " Result :"))
	(if (equalp temp 1)(princ "("))
	(if (equalp temp 1)(princ (subseq (string it) 6 (length (string it)))))
	(if (equalp temp 2)(print "Syntax OK"))
	(if (equalp temp 2)(princ "Result : "))
	(if (equalp temp 2)(setq str (subseq (string it) 7 (length (string it)))))
	(if (equalp temp 2)(princ str))
	(if (equalp temp 2) 
	(loop for i = 6 then (1+ j)
          as j = (position #\Space it :start i) 
        
          while j
		  do (if (equalp (subseq it i j) "") ()
			(setq wordList (nconc wordList (list  (subseq it i j)))))
		do (setq tem (+ 1 j))
		  
	))
	(setq wordList nil)
	(if (equalp (subseq (string it) 0 6) "(liste")(setq temp 4))
	(if (equalp temp 4)(print "SYNTAX_ERROR liste cannot be tokenized "))

	(if (equalp (subseq (string it) 0 6) "(list ")(setq temp 5))
	(if (equalp temp 5)(print "Syntax OK"))
	(if (equalp temp 5)(princ " Result :"))
	(if (equalp temp 5) 
	(loop for i = 5 then (1+ j)
          as j = (position #\Space it :start i) 
        
          while j
		  do (if (equalp (subseq it i j) "") ()
			(setq wordList (nconc wordList (list  (subseq it i j)))))
		do (setq tem (+ 1 j))
		  
	))
	(if (equalp temp 5) (princ "("))
	(if (equalp temp 5) (setq wordList (nconc wordList (list  (subseq it tem (length (string it)))))))
	(if (equalp temp 5) (map 'list (lambda (c)
		(princ " ")
		 (if (equalp (position-if #'digit-char-p (string c)) nil)(princ c)
		  (princ c))) wordList)
	)
	(setq wordList nil)
	;(if (equalp temp 5)(print ")"))
	(setq w 0)
	(if  (equalp temp nil) (setq w 1))
	(setq temp1  nil)
	(setq o 1)
	(setq iter it)
	(if  (equalp w 1)
	(loop for p = 0 then (1+ k)
          as k = (position #\Space iter :start p) 
        
          while k
		  ;do (print (subseq iter p k))
		  do (if (equalp (subseq iter p k) "") () (setq o 0))
		  do (if (equalp o 0)(setq wordList (nconc wordList (list (subseq  iter p k)))))
		  do (setq tem (+ 1 k))
	))
	 (if (equalp wordList nil) ()(setq wordList (nconc wordList (list (subseq  iter tem (length (string iter)))))))
	 (if (equalp wordList nil) ()(map 'list (lambda (ite)
	 (if (equalp "(if" ite)(setq temp1 10))
  	 (if (equalp "(while" ite)(setq temp1 10))
	 (if (equalp "(set" ite)(setq temp1 21))
	 (if (equalp "(exit)" ite)(setq temp1 24))
	 (if (equalp "(for" ite)(setq temp1 11))
		 (if (equalp "(equal" ite)(setq temp1 13))
		 (if (equalp "(not" ite)(setq temp1 13))
		 (if (equalp "(and" ite)(setq temp1 14))
		 (if (equalp "(or" ite)(setq temp1 15))
		 (if (equalp "T" ite)(setq temp1 16))
		 (if (equalp "F" ite)(setq temp1 17))
		 (if (equalp "(append" ite)(setq temp1 18))
		  (if (equalp "(**" ite)(setq temp1 34))
		 (if (equalp "," ite)(setq temp1 1))
		 (if (equalp "“" ite)(setq temp1 8))
		 (if (equalp "“" ite)(setq temp1 9))
		 (if (equalp "**" ite)(setq temp1 7))
		 (if (equalp "(++" ite)(setq temp1 200))
		 (if (equalp "(--" ite)(setq temp1 201))
		 (if (equal temp1 200) ()(if (string= "(+" ite)(setq temp1 30)))
		 (if (equal temp1 201) ()(if (string= "(-" ite)(setq temp1 31)))
		 (if (equalp "(*" ite)(setq temp1 32))
		 (if (equalp "(/" ite)(setq temp1 33))
		 (if (equalp "+" ite)(setq temp1 0))
		 (if (equalp "*" ite)(setq temp1 5))
		 (if (equalp "-" ite)(setq temp1 99))
		 (if (equalp "/" ite)(setq temp1 4))
		 (setq yedek 0)
		 (if (equalp "(concat" ite)(setq temp1 19))
		 (if (equalp temp1 13)(print "Syntax OK"))
		 
		 (if (equalp temp1 14)(print "Syntax OK"))

		 (if (equalp temp1 15)(print "Syntax OK"))
		
		 (if (equalp temp1 17)(print "Syntax OK"))
		 
		 (if (equalp temp1 16)(print "Syntax OK"))
		
		 (if (equalp temp1 18)(print "Syntax OK"))

		 (if (equalp temp1 12)(print "Syntax OK"))
		 (if (equalp temp1 10)(print "Syntax OK"))
		 (if (equalp temp1 11)(print "Syntax OK"))
		 (if (equalp temp1 1)(print "Syntax OK"))
		 (if (equalp temp1 0)(print "Syntax OK"))
		 (if (equalp temp1 99)(print "Syntax OK"))
		 (if (equalp temp1 4)(print "Syntax OK"))
		 (if (equalp temp1 5)(print "Syntax OK"))
		 (if (equalp temp1 7)(print "Syntax OK"))
		  (if (equalp temp1 19)(print "Syntax OK"))
		  (if (equalp temp1 20)(print "Syntax OK"))
		  (if (equalp temp1 21)(print "Syntax OK"))
		  (if (equalp temp1 22)(print "Syntax OK"))
		  (if (equalp temp1 23)(print "Syntax OK"))
		  (if (equalp temp1 24)(print "Syntax OK"))
	
		  (if (equalp temp1 30)(print "Syntax OK"))
		
		  (if (equalp temp1 31)(print "Syntax OK"))
		
		  (if (equalp temp1 32)(print "Syntax OK"))
		  
		  (if (equalp temp1 33)(print "Syntax OK"))
		 	
		  (if (equalp temp1 34)(print "Syntax OK"))
		
		  (if (equalp temp1 30)(princ it))
		  (setq per 0)
		  (setq res 0)
		  (setq kiter 0)
		  (if (equalp temp1 200)
		   (loop for piteration = 0 then (1+ kiteration)
			          as kiteration = (position #\Space it :start piteration) 
			        
			          while kiteration
			          do (setq per (+ 1 per))
			          do (setq kiter kiteration)
			          do (if (equalp (position-if #'digit-char-p (subseq it piteration kiteration)) nil) ()(setq res (parse-integer (subseq it piteration kiteration))))
				)
		  )
		   (if (equalp temp1 200)(if (equalp per 1) (setq res (+ 1 (parse-integer (subseq it (+ 1 kiter)  (- (length (string it)) 1)))))))
		 (if (equalp temp1 200) (if (equalp per 1) (print "Syntax OK")))
		  (if (equalp temp1 200)(if (equalp per 1) (princ "Result :")))
		  (if (equalp temp1 200)(if (equalp per 1) (princ res)))
		 (if (equalp temp1 200) (if (equalp per 1) ()(print "SYNTAX_ERROR Expression not recognized ")))
		  (setq per 0)
		  (setq k 0)
		  (setq res 0)
		  (if (equalp temp1 201)
		   (loop for p = 0 then (1+ k)
			          as k = (position #\Space it :start p) 
			        
			          while k
			     	  do (setq kiter k)
			          do (setq per (+ 1 per))
			          do (if (equalp (position-if #'digit-char-p (subseq it p k)) nil) ()(setq res (parse-integer (subseq it p k))))
				)
		  )
		  ;;(print res)
		   (if (equalp temp1 201)(if (equalp per 1) (setq res (- (parse-integer (subseq it (+ 1 kiter)  (- (length (string it)) 1))) 1))))
		 (if (equalp temp1 201) (if (equalp per 1) (print "Syntax OK")))
		  (if (equalp temp1 201)(if (equalp per 1) (princ "Result :")))
		  (if (equalp temp1 201)(if (equalp per 1) (princ res)))
		 (if (equalp temp1 201) (if (equalp per 1) ()(print "SYNTAX_ERROR Expression not recognized ")))
		  (setq per 0)
		  (setq k 0)

		  (setq token nil)
		  (if (equalp temp1 30)
		  		(loop for p = 0 then (1+ k)
			          as k = (position #\Space it :start p) 
			        
			          while k
					 ; do (print (subseq it p k))
					  do (if (equalp (subseq it p k) "") ()(setq token (nconc token (list (subseq  it p k)))))
					  do (setq tem (+ 1 k))
				)
			)
		   (if (equalp temp1 31)
		  		(loop for p = 0 then (1+ k)
			          as k = (position #\Space it :start p) 
			        
			          while k
					 ; do (print (subseq it p k))
					  do (if (equalp (subseq it p k) "") ()(setq token (nconc token (list (subseq  it p k)))))
					  do (setq tem (+ 1 k))
				)
			)
		    (if (equalp temp1 32)
		  		(loop for p = 0 then (1+ k)
			          as k = (position #\Space it :start p) 
			        
			          while k
					 ; do (print (subseq it p k))
					  do (if (equalp (subseq it p k) "") ()(setq token (nconc token (list (subseq  it p k)))))
					  do (setq tem (+ 1 k))
				)
			)
			 (if (equalp temp1 33)
		  		(loop for p = 0 then (1+ k)
			          as k = (position #\Space it :start p) 
			        
			          while k
					 ; do (print (subseq it p k))
					  do (if (equalp (subseq it p k) "") ()(setq token (nconc token (list (subseq  it p k)))))
					  do (setq tem (+ 1 k))
				)
			)
		  ;;(if (equalp temp1 30) (print "************token**********"))
		  ;;(if (equalp temp1 30) (print token))
		  (if (equalp temp1 30)(setq tokn (nreverse token)))
		  (if (equalp temp1 31)(setq tokn (nreverse token)))
		  (if (equalp temp1 32)(setq tokn (nreverse token)))
		  (if (equalp temp1 33)(setq tokn (nreverse token)))
		  ;;(if (equalp temp1 30) (print "************untoken**********"))
		  ;;(if (equalp temp1 30)(print tokn))
		  (setq numberList nil)
		  (if (equalp temp1 30)(map 'list (lambda (ci) 
		  (if (equalp ci "(+") (map 'list (lambda (ic) (setq result (+ result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(-") (setq nmberList (nreverse numberList)))
		  (if (equalp ci "(/") (setq nmberList (nreverse numberList)))
		   (setq c 0)
		  ;;(if (equalp ci "(-") (print nmberList))
		  ;;(if (equalp ci "(/") (print nmberList))
		  (if (equalp ci "(-") (map 'list (lambda (ic) (setq result (- (parse-integer (string ic)) result)))nmberList))
		  (if (equalp ci "(-") (setq result (- 0 result )))
		  (if (equalp ci "(*") (map 'list (lambda (ic) (setq result (* result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(/") (map 'list (lambda (ic) (if (equalp c 0)(setq result (parse-integer (string ic)))
		  (setq result (/ result (parse-integer (string ic))))) (setq c (+ c 1)))nmberList))
		  (if (equalp ci "(+") (setq numberList nil)) 
		  (if (equalp ci "(-") (setq numberList nil))
		  (if (equalp ci "(*") (setq numberList nil))
		  (if (equalp ci "(/") (setq numberList nil))
		  ;;(print result)
		  ;(print ci)
		  (if (equalp ci "(+") ()(if(equalp ci "(-")()(if (equalp ci "(*")() (if (equalp ci "(/")()
		  	(setq numberList (nconc numberList (list ci)))))))
		  )tokn))
		  (if (equalp temp1 31)(map 'list (lambda (ci) 
		  (if (equalp ci "(+") (map 'list (lambda (ic) (setq result (+ result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(-") (setq nmberList (nreverse numberList)))
		  (if (equalp ci "(/") (setq nmberList (nreverse numberList)))
		   (setq c 0)
		 ; (if (equalp ci "(-") (print nmberList))
		  ;(if (equalp ci "(/") (print nmberList))
		  (if (equalp ci "(-") (map 'list (lambda (ic) (setq result (- (parse-integer (string ic)) result)))nmberList))
		  (if (equalp ci "(-") (setq result (- 0 result )))
		  (if (equalp ci "(*") (map 'list (lambda (ic) (setq result (* result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(/") (map 'list (lambda (ic) (if (equalp c 0)(setq result (parse-integer (string ic)))
		  (setq result (/ result (parse-integer (string ic))))) (setq c (+ c 1)))nmberList))
		  (if (equalp ci "(+") (setq numberList nil)) 
		  (if (equalp ci "(-") (setq numberList nil))
		  (if (equalp ci "(*") (setq numberList nil))
		  (if (equalp ci "(/") (setq numberList nil))
		  ;(print result)
		  ;(print ci)
		  (if (equalp ci "(+") ()(if(equalp ci "(-")()(if (equalp ci "(*")() (if (equalp ci "(/")()
		  	(setq numberList (nconc numberList (list ci)))))))
		  )tokn))
		  (if (equalp temp1 32)(map 'list (lambda (ci) 
		  (if (equalp ci "(+") (map 'list (lambda (ic) (setq result (+ result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(-") (setq nmberList (nreverse numberList)))
		  (if (equalp ci "(/") (setq nmberList (nreverse numberList)))
		   (setq c 0)
		  ;(if (equalp ci "(-") (print nmberList))
		  ;(if (equalp ci "(/") (print nmberList))
		  (if (equalp ci "(-") (map 'list (lambda (ic) (setq result (- (parse-integer (string ic)) result)))nmberList))
		  (if (equalp ci "(-") (setq result (- 0 result )))
		  (if (equalp ci "(*") (map 'list (lambda (ic) (setq result (* result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(/") (map 'list (lambda (ic) (if (equalp c 0)(setq result (parse-integer (string ic)))
		  (setq result (/ result (parse-integer (string ic))))) (setq c (+ c 1)))nmberList))
		  (if (equalp ci "(+") (setq numberList nil)) 
		  (if (equalp ci "(-") (setq numberList nil))
		  (if (equalp ci "(*") (setq numberList nil))
		  (if (equalp ci "(/") (setq numberList nil))
		  (if (equalp ci "(+") ()(if(equalp ci "(-")()(if (equalp ci "(*")() (if (equalp ci "(/")()
		  	(setq numberList (nconc numberList (list ci)))))))
		  )tokn))
		  (if (equalp temp1 33)(map 'list (lambda (ci) 
		  (if (equalp ci "(+") (map 'list (lambda (ic) (setq result (+ result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(-") (setq nmberList (nreverse numberList)))
		  (if (equalp ci "(/") (setq nmberList (nreverse numberList)))
		   (setq c 0)
		  (if (equalp ci "(-") (map 'list (lambda (ic) (setq result (- (parse-integer (string ic)) result)))nmberList))
		  (if (equalp ci "(-") (setq result (- 0 result )))
		  (if (equalp ci "(*") (map 'list (lambda (ic) (setq result (* result (parse-integer (string ic)))))numberList))
		  (if (equalp ci "(/") (map 'list (lambda (ic) (if (equalp c 0)(setq result (parse-integer (string ic)))
		  (setq result (/ result (parse-integer (string ic))))) (setq c (+ c 1)))nmberList))
		  (if (equalp ci "(+") (setq numberList nil)) 
		  (if (equalp ci "(-") (setq numberList nil))
		  (if (equalp ci "(*") (setq numberList nil))
		  (if (equalp ci "(/") (setq numberList nil))
		  (if (equalp ci "(+") ()(if(equalp ci "(-")()(if (equalp ci "(*")() (if (equalp ci "(/")()
		  	(setq numberList (nconc numberList (list ci)))))))
		  )tokn))
		  
		(setq h (write-to-string result))
		(if (equalp temp1 30) (princ " Result:"))
		(if (equalp temp1 30) (princ h))

		(setq h (write-to-string result))
		(if (equalp temp1 31) (princ " Result:"))
		(if (equalp temp1 31) (princ h))

		(setq h (write-to-string result))
		(if (equalp temp1 32) (princ " Result:"))
		(if (equalp temp1 32) (princ h))
		
		(setq h  (write-to-string result))
		(if (equalp temp1 33) (princ " Result:"))
		(if (equalp temp1 33) (princ h))
		(setq result 0)
		(setq token nil)
		(setq tokn nil)
		(setq selfTemplate (subseq (string it) 7 (length (string it))))
		(if (equalp temp1 18) (print "Result :"))
		(if (equalp temp1 18) (princ "\("))
		(if (equalp temp1 18) 
			(map 'list (lambda (c) 
				(if (equalp c "'")()(if (equalp (string c) "#") ()(if (equalp (string c) "(")()
				 (if (equalp (string c) "\"") () (if (equalp (string c) ")") () (princ c))))))
			)selfTemplate)
		)
		(if (equalp temp1 18) (princ "\)"))
		(setq selfTemplate nil)

		(setq selfTemplate (subseq (string it) 7 (length (string it))))
		(if (equalp temp1 19) (print "Result :"))
		(if (equalp temp1 19) (princ "\("))
		(if (equalp temp1 19) 
			(map 'list (lambda (c) 
				(if (equalp c "'")()(if (equalp (string c) "#") ()(if (equalp (string c) "(")()
				 (if (equalp (string c) "\"") () (if (equalp (string c) ")") () (princ c))))))
			)selfTemplate)
		)
		(if (equalp temp1 19) (princ "\)"))
		(setq selfTemplate nil)
		  (setq tempStr ite)
		(setq temp1 nil)
	)wordList))
	(setq u 0)
	(setq temp nil)
	(setq wordList nil))
	list)
)
(defun rev (list)
  (do ((list list (rest list))
       (reversed '() (list* (first list) reversed)))
      ((endp list) reversed)))

(defun readChar()
	
	(setq c (read-char inputFile nil 'End-File))
	(cond 
		((eq 'End-File c)
				(close inputFile)		
		)
		
	)
	
	(setq readC c)
	(setq charC (determinecharC c))
	(print c)

)
(defconstant KEYWORD "KEYWORD")

(defconstant OPERATOR "OPERATOR")

(defconstant OPERATOR1 "operand")
(defun determinecharC(C)
	(cond 
		((eq 'End-File C)
			EndOfFile
		)
		
		((alpha-char-p C)
			letter
		)
	
		((not (null (digit-char-p C)))
			digit
		)
		
		(t
			undefined
		)
	)
)


(defun lexer(fileName)
	(setq resultList nil)
	(setq inputFile (open fileName)) 
	(readChar)
	(setq lexStr (string ""))

	(lex readC readC charC lexStr)
	(setq resultList (reverse resultList))
	(print resultList)

)

(defun lex(previousCharacter currentChar currentClass lexString)
	(cond
		
		((eq 'End-File currentChar)
			(setToken (getTokenType (determinecharC previousCharacter) previousCharacter) lexString)
			nil
		)
		
		((not (equal (determinecharC previousCharacter) currentClass))
			(cond
					((equal t (isSpaceChar currentChar))
							(getNotSpaceChar)
							(setq currentChar readC)
							(setq currentClass charC)
					)
			)
			(setToken (getTokenType (determinecharC previousCharacter) previousCharacter) lexString)
			(lex currentChar currentChar currentClass lexStr)
		)
		
		((eq currentClass digit)
			(readChar)
			(cond
				((AND (equal currentChar #\0) (= 0 (length lexString)))
					(setToken INTEGER (string #\0))
					(lex currentChar readC charC (string ""))	
				)
				(t
					(lex currentChar readC charC (concatenate 'string lexString (string currentChar)))	
				)
			)
				
		)
		
		((eq currentClass letter)

			(readChar)
			(lex currentChar readC charC (concatenate 'string lexString (string currentChar)))		
		)
		
		((eq currentClass undefined)
			(readChar)
			(getNotSpaceChar)
			(cond
				((AND (eq currentChar #\-) (eq charC digit) (not (eq readC #\0)))
					(lex readC readC charC (concatenate 'string lexString (string currentChar)))
				)
				((AND (eq currentChar #\*) (eq charC undefined) (eq readC #\*))
					(setToken OPERATOR (string "**"))
					(readChar)
					(getNotSpaceChar)
					(lex readC readC charC lexString)		
				)
				(t
					(setToken (getTokenType (determinecharC previousCharacter) previousCharacter) (concatenate 'string lexString (string currentChar)))
					(lex readC readC charC lexString)		
				)
			)	
		)
	)
)

(defun getNotSpaceChar()
	(loop 
		while (and (not (eq readC 'End-File)) (eq t (isSpaceChar readC)))
		  
		  do (readChar)
	)
)

(defun isSpaceChar(c)
		(if(or (eq readC #\tab) (eq readC #\Space) (eq readC #\newline))
			t
			nil
		)
)
(defconstant keywordList '("AND" "OR" "NOT" "EQUAL" "APPEND" "CONCAT" "SET" "DEFFUN" "FOR" "WHILE" "IF" "EXIT"))
(defconstant operatorList '("+" "-" "*" "/" "(" ")"))
(defun getTokenType(classChar characterReaded)

	(cond 
		((eq classChar letter)
			IDENT
		)
		((eq classChar digit)
			INTEGER
		)
		((eq classChar undefined)
			(if (eq t (isOperator characterReaded))
				OPERATOR
				"Invalid Token"
			)
		)
	)
)
(defconstant BINARY "BINARY")
(defconstant IDENT "IDENTIFIER")
(defconstant INTEGER "INTEGER")
(defun isOperator(characterReaded)
	(loop for key in operatorList
		do

		(cond 

			((equal  (string characterReaded) key)
				(return-from isOperator t)
			)
		)
			
	)
	(return-from isOperator nil)
)
(defun isInKeywordList(lexString)
	(loop for key in keywordList
		do
		(cond 

			((equal  (string-upcase lexString) key)
				(return-from isInKeywordList t)
			)
		)
			
	)
	(return-from isInKeywordList nil)
)
(defun setToken(tokenName lexemeString)
	(cond
		((> (length lexemeString) 0)
				(cond 
					((or (equal (string-upcase lexemeString) "TRUE") (equal (string-upcase lexemeString) "FALSE"))
						(setq tokenName BINARY)
					)
					((eq t (isInKeywordList lexemeString))
						(setq tokenName KEYWORD)

					)
				)
				(setq token '())
				(push  (append lexemeString) token)
				(push  tokenName token)
				(push token resultList)
		)		
	)
)

(lexer "C:\\Users\\crngm\\Desktop\\ABC\\helloworld.lisp")
(read-as-list "C:\\Users\\crngm\\Desktop\\ABC\\helloworld.lisp")

;;(load "C:\\Users\\crngm\\Desktop\\ABC\\gpp_interpreter.cl")
